# OpenAPI generated server

Spring Boot Server

## Overview
This server was generated by the [OpenAPI Generator](https://openapi-generator.tech) project.
By using the [OpenAPI-Spec](https://openapis.org), you can easily generate a server stub.
This is an example of building a OpenAPI-enabled server in Java using the SpringBoot framework.


The underlying library integrating OpenAPI to Spring Boot is [springdoc](https://springdoc.org).
Springdoc will generate an OpenAPI v3 specification based on the generated Controller and Model classes.
The specification is available to download using the following url:
http://localhost:8081/v3/api-docs/

Start your server as a simple java application

You can view the api documentation in swagger-ui by pointing to
http://localhost:8081/swagger-ui.html

Change default port value in application.properties

# RUN APP IN LOCAL ENVIRONMENT

## PRE REQUIREMENTS

1. Docker
2. Gradle 8.1.1
3. Java 17


The application is made with java 17 and Spring Framework 3 at the time of execution it uses the following compose file that raises a redis image and a PostgreSQL image

```yaml
version: '3.8'
services:
  redis:
    image: "redis/redis-stack:latest"
    ports:
      - "26379:6379"
    container_name : redis
    networks:
      - vehicle
    environment:
      - REDIS_REPLICATION_MODE=master
      - ALLOW_EMPTY_PASSWORD=yes
  database:
    image: 'postgres:15.2'
    ports:
      - '25432:5432'
    container_name : database
    networks:
      - vehicle
    environment:
      - 'POSTGRES_USER=myuser'
      - 'POSTGRES_DB=mydatabase'
      - 'POSTGRES_PASSWORD=secret'
networks:
  vehicle:
```

This app run in port 8080 and use the following application.properties

```properties
server.port=8080
spring.jackson.date-format=ec.pichincha.challenge.RFC3339DateFormat
spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=false
spring.main.allow-bean-definition-overriding=true

spring.application.name= service-vehicle
spring.car.model.uri = https://kerner.hyundai.com.ec/api/versiones
spring.live.coin.watch.uri = https://http-api.livecoinwatch.com/coins/%s/about?currency=%s
spring.coin.lore.uri = https://api.coinlore.net/api/ticker/

entity.cache.ttl = 300
spring.r2dbc.url= r2dbc:postgresql://localhost:25432/mydatabase
spring.r2dbc.username = myuser
spring.r2dbc.password = secret

spring.datasource.url=jdbc:postgresql://localhost:25432/mydatabase
spring.datasource.username=myuser
spring.datasource.password=secret

spring.data.redis.host=localhost
spring.data.redis.port=26379
spring.data.redis.password=

#spring.flyway.url=jdbc:postgresql://localhost:5432/mydatabase
#spring.flyway.user=myuser
#spring.flyway.password=secret
spring.flyway.enabled=true
spring.flyway.baseline-version=1
spring.flyway.schemas=public
spring.flyway.locations=classpath:db/migration
spring.flyway.sql-migration-suffixes=.sql
spring.flyway.baseline-on-migrate=true
spring.flyway.sql-migration-prefix=V
spring.flyway.validateMigrationNaming=true

````

## LET'S DO IT

1. Run app:

```shell
gradle bootRun
```

2. For consume generate quote service, use the following curl

```shell
curl --location 'http://localhost:8080/vehicle/v1/quotes/generate' \
--header 'Content-Type: application/json' \
--header 'Accept: application/json' \
--data '{
"data": {
"model": "ACCENT",
"cryptocurrency": "ETH"
}
}'
```
The response of this service is ...

```json
{
    "data": {
        "convertionId": "ee41de3e-3e26-4925-9353-80d11927312d",
        "conversionTimelife": "300 seconds",
        "versions": [
            {
                "model": "ACCENT",
                "version": "ALL NEW ACCENT L",
                "priceUsd": 18990,
                "priceCryptocurrency": 9.482,
                "cryptocurrency": "ETH"
            },
            {
                "model": "ACCENT",
                "version": "ALL NEW ACCENT GL",
                "priceUsd": 20490,
                "priceCryptocurrency": 10.231,
                "cryptocurrency": "ETH"
            },
            {
                "model": "ACCENT",
                "version": "ALL NEW ACCENT GLS",
                "priceUsd": 22190,
                "priceCryptocurrency": 11.080,
                "cryptocurrency": "ETH"
            }
        ]
    }
}
````

2. To save a quote, use the data generated in the quote "conversionId", "cryptocurrency", "model", "version"

```shell
curl --location 'http://localhost:8080/vehicle/v1/quotes/save' \
--header 'Content-Type: application/json' \
--header 'Accept: application/json' \
--data '{
  "data": {
    "cryptocurrency": "ETH",
    "convertionId": "ee41de3e-3e26-4925-9353-80d11927312d",
    "fullName": "demostracion",
    "model": "ACCENT",
    "version": "ALL NEW ACCENT GL"
  }
}'
```
The response of this service is...

```json
{
    "data": {
        "fullName": "demostracion",
        "version": "ALL NEW ACCENT GL",
        "model": "ACCENT",
        "cryptocurrency": "ETH",
        "priceUsd": 20490,
        "priceCryptocurrency": 10.231,
        "date": "2023-07-14:12:27:18",
        "purchaseId": "617ea9fd-443c-4ca4-bc8b-b880f071793e"
    }
}
```

3. To view the report of sales made on a specific day, the following curl is used with the following attributes
- "date" date in YYYY-MM-dd format
- "model" vehicle model, allowed values [ ACCENT, TUCSON, SANTA FE, GRAND i10 ]
- "cryptocurrency" type of cryptocurrency accepted values [ ETH, BTC ]

```shell
curl --location 'http://localhost:8080/vehicle/v1/reports/generate' \
--header 'Content-Type: application/json' \
--header 'Accept: application/json' \
--data '{
  "data": {
    "date": "2023-07-12",
    "model": "ACCENT",
    "cryptocurrency": "ETH"
  }
}'
```
The response from this service shows the sales for that day grouped by version, with the accumulated value and price in dollars and cryptocurrency at the time the price was registered.

```json
{
    "data": [
        {
            "date": "2023-07-12",
            "version": "ALL NEW ACCENT GL",
            "model": "ACCENT",
            "cryptocurrency": "ETH",
            "usdAmount": 20490.00,
            "cryptocurrencyAmount": 10.96
        },
        {
            "date": "2023-07-12",
            "version": "ALL NEW ACCENT L",
            "model": "ACCENT",
            "cryptocurrency": "ETH",
            "usdAmount": 37980.00,
            "cryptocurrencyAmount": 20.32
        }
    ]
}
```

# RUN IN DOCKER

1. For run the app in docker use this file compose.yaml 

```yaml
version: '3.8'
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - 8181:8181
    container_name : app
    networks:
      - vehicle
    depends_on:
      - redis
      - database
  redis:
    image: "redis/redis-stack:latest"
    ports:
      - "26379:6379"
    container_name : redis
    networks:
      - vehicle
    environment:
      - REDIS_REPLICATION_MODE=master
      - ALLOW_EMPTY_PASSWORD=yes
  database:
    image: 'postgres:15.2'
    ports:
      - '25432:5432'
    container_name : database
    networks:
      - vehicle
    environment:
      - 'POSTGRES_USER=myuser'
      - 'POSTGRES_DB=mydatabase'
      - 'POSTGRES_PASSWORD=secret'
networks:
  vehicle:
```

2. Change file application.properties

```properties
server.port=8181
spring.jackson.date-format=ec.pichincha.challenge.RFC3339DateFormat
spring.jackson.serialization.WRITE_DATES_AS_TIMESTAMPS=false
spring.main.allow-bean-definition-overriding=true

spring.application.name= service-vehicle
spring.car.model.uri = https://kerner.hyundai.com.ec/api/versiones
spring.live.coin.watch.uri = https://http-api.livecoinwatch.com/coins/%s/about?currency=%s
spring.coin.lore.uri = https://api.coinlore.net/api/ticker/

entity.cache.ttl = 300
spring.r2dbc.url= r2dbc:postgresql://database:5432/mydatabase
spring.r2dbc.username = myuser
spring.r2dbc.password = secret

spring.datasource.url=jdbc:postgresql://database:5432/mydatabase
spring.datasource.username=myuser
spring.datasource.password=secret

spring.data.redis.host=redis
spring.data.redis.port=6379
spring.data.redis.password=

spring.flyway.url=jdbc:postgresql://database:5432/mydatabase
spring.flyway.user=myuser
spring.flyway.password=secret
spring.flyway.enabled=true
spring.flyway.baseline-version=1
spring.flyway.schemas=public
spring.flyway.locations=classpath:db/migration
spring.flyway.sql-migration-suffixes=.sql
spring.flyway.baseline-on-migrate=true
spring.flyway.sql-migration-prefix=V
spring.flyway.validateMigrationNaming=true
logging.level.root=debug



```

3. Use this file Dockerfile for install from sources

```docker
FROM openjdk:17-jdk-slim AS build

# Set the working directory in the container
WORKDIR /app

# Copy the Gradle build files
COPY build.gradle .
COPY settings.gradle .
COPY gradlew .
COPY gradle gradle

# Download and cache the Gradle distribution
RUN ./gradlew --version

# Copy the source code
COPY . .

# Build the application using Gradle
RUN ./gradlew build -x test

# Create a minimal JRE-based image
FROM openjdk:17-jdk-slim

# Set the working directory in the container
WORKDIR /app

# Copy the JAR file from the build stage
COPY --from=build /app/build/libs/vehicule-0.0.1-SNAPSHOT.jar .

# Set the entrypoint to launch the application
ENTRYPOINT ["java", "-jar", "vehicle-0.0.1-SNAPSHOT.jar"]
```

4.  Or use this file for copy jar, previously generate with Run this command
```properties
FROM openjdk:17-jdk-slim

# Set the working directory in the container
WORKDIR /app

# Copy the application JAR file to the container
COPY build/libs/vehicle-0.0.1-SNAPSHOT.jar app.jar

# Expose the desired ports
EXPOSE 8181

# Launch the application when the container starts
ENTRYPOINT ["java", "-jar", "app.jar"]
```
```shell
gradle build -x test
```
5. Run this command for generate a imagen of Docker


```shell
docker-compose up --build -d
```
The `docker-compose up -d` command is used to start the services defined in a Docker Compose file in detached mode. Here's an explanation of the command:

* `docker-compose`: This is the command-line tool for managing Docker Compose files and orchestrating multiple containers.
* `up`: This subcommand tells Docker Compose to start the services defined in the Compose file.
* `-d` or `--detach`: This flag runs the containers in detached mode, meaning they run in the background and do not attach the container's input/output to the terminal. This allows you to continue using the terminal while the containers are running.

When you run `docker-compose up --build -d`, Docker Compose reads the `compose.yml` (or other specified) file in the current directory and starts the services defined within it. The services are started as individual containers, each with their own isolated environment.

The `-d` flag is optional. If you omit it, the containers will start in the foreground, and their logs will be displayed in the terminal. Using `-d` allows you to start the containers and continue working in the terminal without being interrupted by container logs.

The `docker-compose.yml` file defines the services, including their configurations, dependencies, and network setup. It can specify things like the Docker images to use, container names, ports, environment variables, volumes, and more.

It's important to ensure that you have Docker Compose installed on your system before using the `docker-compose` command. You can check if it is installed by running `docker-compose --version`.

6. The application is deployed on port `8181` and the mentioned curls can be used
   previously


